<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>containers on Major Hayden's Blog ðŸ¤ </title><link>https://major.io/tags/containers/</link><description>Recent content in containers on Major Hayden's Blog ðŸ¤ </description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Fri, 16 Aug 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://major.io/tags/containers/index.xml" rel="self" type="application/rss+xml"/><item><title>Get faster GitLab runners with a ramdisk</title><link>https://major.io/2019/08/16/get-faster-gitlab-runners-with-a-ramdisk/</link><pubDate>Fri, 16 Aug 2019 00:00:00 +0000</pubDate><guid>https://major.io/2019/08/16/get-faster-gitlab-runners-with-a-ramdisk/</guid><description>When you build tons of kernels every day like my team does, you look for speed improvements anywhere you can. Caching repositories, artifacts, and compiled objects makes kernel builds faster and it reduces infrastructure costs.
Need for speed We use GitLab CI in plenty of places, and that means we have a lot of gitlab-runner configurations for OpenShift (using the kubernetes executor) and AWS (using the docker-machine executor). The runner&amp;rsquo;s built-in caching makes it easy to upload and download cached items from object storage repositories like Google Cloud Storage or Amazon S3.</description></item><item><title>buildah error: vfs driver does not support overlay.mountopt options</title><link>https://major.io/2019/08/13/buildah-error-vfs-driver-does-not-support-overlay-mountopt-options/</link><pubDate>Tue, 13 Aug 2019 00:00:00 +0000</pubDate><guid>https://major.io/2019/08/13/buildah-error-vfs-driver-does-not-support-overlay-mountopt-options/</guid><description>Buildah and podman make a great pair for building, managing and running containers on a Linux system. You can even use them with GitLab CI with a few small adjustments, namely the switch from the overlayfs to vfs storage driver.
I have some regularly scheduled GitLab CI jobs that attempt to build fresh containers each morning and I use these to get the latest packages and find out early when something is broken in the build process.</description></item><item><title>Build containers in GitLab CI with buildah</title><link>https://major.io/2019/05/24/build-containers-in-gitlab-ci-with-buildah/</link><pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate><guid>https://major.io/2019/05/24/build-containers-in-gitlab-ci-with-buildah/</guid><description>My team at Red Hat depends heavily on GitLab CI and we build containers often to run all kinds of tests. Fortunately, GitLab offers up CI to build containers and a container registry in every repository to hold the containers we build.
This is really handy because it keeps everything together in one place: your container build scripts, your container build infrastructure, and the registry that holds your containers. Better yet, you can put multiple types of containers underneath a single git repository if you need to build containers based on different Linux distributions.</description></item><item><title>Use a secret as an environment variable in OpenShift deployments</title><link>https://major.io/2018/12/06/use-secret-as-environment-variable-in-openshift-deployments/</link><pubDate>Thu, 06 Dec 2018 00:00:00 +0000</pubDate><guid>https://major.io/2018/12/06/use-secret-as-environment-variable-in-openshift-deployments/</guid><description>OpenShift deployments allow you to take a container image and run it within a cluster. You can easily add extra items to the deployment, such as environment variables or volumes.
The best practice for sensitive environment variables is to place them into a secret object rather than directly in the deployment configuration itself. Although this keeps the secret data out of the deployment, the environment variable is still exposed to the running application inside the container.</description></item><item><title>Whatâ€™s Happening in OpenStack-Ansible (WHOA) â€“ July 2016</title><link>https://major.io/2016/07/22/whats-happening-in-openstack-ansible-whoa-july-2016/</link><pubDate>Fri, 22 Jul 2016 15:48:18 +0000</pubDate><guid>https://major.io/2016/07/22/whats-happening-in-openstack-ansible-whoa-july-2016/</guid><description>This post is the second installment in the series of What&amp;rsquo;s Happening in OpenStack-Ansible (WHOA) posts that I&amp;rsquo;m assembling each month. My goal is to inform more people about what we&amp;rsquo;re doing in the OpenStack-Ansible community and bring on more contributors to the project.
July brought lots of changes for the OpenStack-Ansible project and the remaining work for the Newton release is coming together well. Many of the changes made in the Newton branch have made deployments faster, more reliable and more repeatable.</description></item><item><title>Whatâ€™s Happening in OpenStack-Ansible (WHOA) â€“ June 2016</title><link>https://major.io/2016/06/15/whats-happening-openstack-ansible-whoa-june-2016/</link><pubDate>Wed, 15 Jun 2016 19:58:52 +0000</pubDate><guid>https://major.io/2016/06/15/whats-happening-openstack-ansible-whoa-june-2016/</guid><description>The world of OpenStack moves quickly. Each day brings new features, new bug fixes, and new ways of thinking. The OpenStack-Ansible community strives to understand these changes and make them easier for operators to implement.
The OpenStack-Ansible project is a collection of playbooks and roles written by operators for operators. These playbooks make it easier to deploy, maintain, and upgrade an OpenStack cloud.
Keeping up with the changes in the OpenStack-Ansible project is challenging.</description></item><item><title>Research Paper: Securing Linux Containers</title><link>https://major.io/2015/08/14/research-paper-securing-linux-containers/</link><pubDate>Fri, 14 Aug 2015 20:45:50 +0000</pubDate><guid>https://major.io/2015/08/14/research-paper-securing-linux-containers/</guid><description>It seems like there&amp;rsquo;s a new way to run containers every week. The advantages and drawbacks of each approach are argued about on mailing lists, in IRC channels, and in person, around the world. However, the largest amount of confusion seems to be around security.
Launching secure containers I&amp;rsquo;ve written about launching secure containers on this blog many times before:
Launch secure LXC containers on Fedora 20 using SELinux and sVirt Improving LXC template security Try out LXC with an Ansible playbook CoreOS vs.</description></item><item><title>Improving LXC template security</title><link>https://major.io/2015/06/18/improving-lxc-template-security/</link><pubDate>Thu, 18 Jun 2015 19:52:11 +0000</pubDate><guid>https://major.io/2015/06/18/improving-lxc-template-security/</guid><description>I&amp;rsquo;ve been getting involved with the Fedora Security Team lately and we&amp;rsquo;re working as a group to crush security bugs that affect Fedora, CentOS (via EPEL) and Red Hat Enterprise Linux (via EPEL). During some of this work, I stumbled upon a group of Red Hat Bugzilla tickets talking about LXC template security.
The gist of the problem is that there&amp;rsquo;s a wide variance in how users and user credentials are handled by the different LXC templates.</description></item><item><title>Try out LXC with an Ansible playbook</title><link>https://major.io/2014/12/17/try-lxc-ansible-playbook/</link><pubDate>Wed, 17 Dec 2014 13:50:26 +0000</pubDate><guid>https://major.io/2014/12/17/try-lxc-ansible-playbook/</guid><description>The world of containers is constantly evolving lately. The latest turn of events involves the CoreOS developers when they announced Rocket as an alternative to Docker. However, LXC still lingers as a very simple path to begin using containers.
When I talk to people about LXC, I often hear people talk about how difficult it is to get started with LXC. After all, Docker provides an easy-to-use image downloading function that allows you to spin up multiple different operating systems in Docker containers within a few minutes.</description></item><item><title>Launch secure LXC containers on Fedora 20 using SELinux and sVirt</title><link>https://major.io/2014/04/21/launch-secure-lxc-containers-on-fedora-20-using-selinux-and-svirt/</link><pubDate>Tue, 22 Apr 2014 04:11:00 +0000</pubDate><guid>https://major.io/2014/04/21/launch-secure-lxc-containers-on-fedora-20-using-selinux-and-svirt/</guid><description>Getting started with LXC is a bit awkward and I&amp;rsquo;ve assembled this guide for anyone who wants to begin experimenting with LXC containers in Fedora 20. As an added benefit, you can follow almost every step shown here when creating LXC containers on Red Hat Enterprise Linux 7 Beta (which is based on Fedora 19).
You&amp;rsquo;ll need a physical machine or a VM running Fedora 20 to get started. (You could put a container in a container, but things get a little dicey with that setup.</description></item><item><title>Docker, trusted builds, and Fedora 20</title><link>https://major.io/2014/03/26/docker-trusted-builds-and-fedora-20/</link><pubDate>Wed, 26 Mar 2014 05:17:58 +0000</pubDate><guid>https://major.io/2014/03/26/docker-trusted-builds-and-fedora-20/</guid><description>Docker is a hot topic in the Linux world at the moment and I decided to try out the new trusted build process. Long story short, you put your Dockerfile along with any additional content into your GitHub repository, link your GitHub account with Docker, and then fire off a build. The Docker index labels it as &amp;ldquo;trusted&amp;rdquo; since it was build from source files in your repository.
I set off to build a Dockerfile to provision a container that would run all of the icanhazip services.</description></item></channel></rss>