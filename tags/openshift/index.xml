<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>openshift on Major Hayden's Blog ü§†</title><link>https://major.io/tags/openshift/</link><description>Recent content in openshift on Major Hayden's Blog ü§†</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Mon, 18 Nov 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://major.io/tags/openshift/index.xml" rel="self" type="application/rss+xml"/><item><title>Monitoring OpenShift cron jobs</title><link>https://major.io/2019/11/18/monitoring-openshift-cron-jobs/</link><pubDate>Mon, 18 Nov 2019 00:00:00 +0000</pubDate><guid>https://major.io/2019/11/18/monitoring-openshift-cron-jobs/</guid><description>Moving applications into an entirely containerized deployment, such as OpenShift or Kubernetes, requires care and attention. One aspect of both that is often overlooked is scheduled jobs, or cron jobs. ‚è∞
Cron jobs in OpenShift allow you to run certain containers on a regular basis and execute certain applications or scripts in those containers. You can use them to trigger GitLab CI pipelines, run certain housekeeping tasks in web applications, or run backups.</description></item><item><title>Deploy monit in OpenShift</title><link>https://major.io/2019/09/11/deploy-monit-in-openshift/</link><pubDate>Wed, 11 Sep 2019 00:00:00 +0000</pubDate><guid>https://major.io/2019/09/11/deploy-monit-in-openshift/</guid><description>Monit is a tried-and-true method for monitoring all kinds of systems, services, and network endpoints. Deploying monit is easy. There&amp;rsquo;s only one binary daemon to run and it reads monitoring configuration from files in a directory you specify.
Most Linux distributions have a package for monit and the package usually contains some basic configuration along with a systemd unit file to run the daemon reliably.
However, this post is all about how to deploy it inside OpenShift.</description></item><item><title>Inspecting OpenShift cgroups from inside the pod</title><link>https://major.io/2019/04/05/inspecting-openshift-cgroups-from-inside-the-pod/</link><pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate><guid>https://major.io/2019/04/05/inspecting-openshift-cgroups-from-inside-the-pod/</guid><description>My team at Red Hat builds a lot of kernels in OpenShift pods as part of our work with the Continuous Kernel Integration (CKI) project. We have lots of different pod sizes depending on the type of work we are doing and our GitLab runners spawn these pods based on the tags in our GitLab CI pipeline.
Compiling with make When you compile a large software project, such as the Linux kernel, you can use multiple CPU cores to speed up the build.</description></item><item><title>Running Ansible in OpenShift with arbitrary UIDs</title><link>https://major.io/2019/03/22/running-ansible-in-openshift-with-arbitrary-uids/</link><pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate><guid>https://major.io/2019/03/22/running-ansible-in-openshift-with-arbitrary-uids/</guid><description>My work at Red Hat involves testing lots and lots of kernels from various sources and we use GitLab CE to manage many of our repositories and run our CI jobs. Those jobs run in thousands of OpenShift containers that we spawn every day.
OpenShift has some handy security features that we like. First, each container is mounted read-only with some writable temporary space (and any volumes that you mount). Also, OpenShift uses arbitrarily assigned user IDs (UIDs) for each container.</description></item><item><title>Use a secret as an environment variable in OpenShift deployments</title><link>https://major.io/2018/12/06/use-secret-as-environment-variable-in-openshift-deployments/</link><pubDate>Thu, 06 Dec 2018 00:00:00 +0000</pubDate><guid>https://major.io/2018/12/06/use-secret-as-environment-variable-in-openshift-deployments/</guid><description>OpenShift deployments allow you to take a container image and run it within a cluster. You can easily add extra items to the deployment, such as environment variables or volumes.
The best practice for sensitive environment variables is to place them into a secret object rather than directly in the deployment configuration itself. Although this keeps the secret data out of the deployment, the environment variable is still exposed to the running application inside the container.</description></item></channel></rss>