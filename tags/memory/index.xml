<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>memory on Major Hayden's Blog ðŸ¤ </title><link>https://major.io/tags/memory/</link><description>Recent content in memory on Major Hayden's Blog ðŸ¤ </description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Tue, 16 Feb 2010 18:00:29 +0000</lastBuildDate><atom:link href="https://major.io/tags/memory/index.xml" rel="self" type="application/rss+xml"/><item><title>MySQL: The total number of locks exceeds the lock table size</title><link>https://major.io/2010/02/16/mysql-the-total-number-of-locks-exceeds-the-lock-table-size-2/</link><pubDate>Tue, 16 Feb 2010 18:00:29 +0000</pubDate><guid>https://major.io/2010/02/16/mysql-the-total-number-of-locks-exceeds-the-lock-table-size-2/</guid><description>If you&amp;rsquo;re running an operation on a large number of rows within a table that uses the InnoDB storage engine, you might see this error:
ERROR 1206 (HY000): The total number of locks exceeds the lock table size
MySQL is trying to tell you that it doesn&amp;rsquo;t have enough room to store all of the row locks that it would need to execute your query. The only way to fix it for sure is to adjust innodb_buffer_pool_size and restart MySQL.</description></item><item><title>MySQL: The total number of locks exceeds the lock table size</title><link>https://major.io/2010/01/29/mysql-the-total-number-of-locks-exceeds-the-lock-table-size/</link><pubDate>Fri, 29 Jan 2010 13:12:21 +0000</pubDate><guid>https://major.io/2010/01/29/mysql-the-total-number-of-locks-exceeds-the-lock-table-size/</guid><description>This problem has cropped up for me a few times, but I&amp;rsquo;ve always forgotten to make a post about it. If you&amp;rsquo;re working with a large InnoDB table and you&amp;rsquo;re updating, inserting, or deleting a large volume of rows, you may stumble upon this error:
InnoDB stores its lock tables in the main buffer pool. This means that the number of locks you can have at the same time is limited by the innodb_buffer_pool_size variable that was set when MySQL was started.</description></item><item><title>Reduce disk I/O for small reads using memory</title><link>https://major.io/2008/08/07/reduce-disk-io-for-small-reads-using-memory/</link><pubDate>Thu, 07 Aug 2008 17:00:27 +0000</pubDate><guid>https://major.io/2008/08/07/reduce-disk-io-for-small-reads-using-memory/</guid><description>Many applications that are used on a standard server perform quite a few of small writes to the disk (like MySQL or Apache). These writes can pile up and limit the performance of your applications. If you have kernel 2.6.9 or later, you can adjust how these small writes are handled to allow for better performance.
There&amp;rsquo;s two main kernel variables to know:
vm.dirty_ratio - The highest % of your memory that can be used to hold dirty data.</description></item></channel></rss>