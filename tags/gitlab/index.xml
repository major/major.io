<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gitlab on Major Hayden ðŸ¤ </title><link>https://major.io/tags/gitlab/</link><description>Recent content in gitlab on Major Hayden ðŸ¤ </description><generator>Hugo -- gohugo.io</generator><copyright>&lt;a href="https://creativecommons.org/licenses/by-sa/2.0/" target="_blank" rel="noopener">CC BY-SA 2.0&lt;/a></copyright><lastBuildDate>Fri, 16 Aug 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://major.io/tags/gitlab/index.xml" rel="self" type="application/rss+xml"/><item><title>Get faster GitLab runners with a ramdisk</title><link>https://major.io/2019/08/16/get-faster-gitlab-runners-with-a-ramdisk/</link><pubDate>Fri, 16 Aug 2019 00:00:00 +0000</pubDate><guid>https://major.io/2019/08/16/get-faster-gitlab-runners-with-a-ramdisk/</guid><description>When you build tons of kernels every day like my team does, you look for speed improvements anywhere you can. Caching repositories, artifacts, and compiled objects makes kernel builds faster and it reduces infrastructure costs.
Need for speed We use GitLab CI in plenty of places, and that means we have a lot of gitlab-runner configurations for OpenShift (using the kubernetes executor) and AWS (using the docker-machine executor). The runner&amp;rsquo;s built-in caching makes it easy to upload and download cached items from object storage repositories like Google Cloud Storage or Amazon S3.</description></item><item><title>buildah error: vfs driver does not support overlay.mountopt options</title><link>https://major.io/2019/08/13/buildah-error-vfs-driver-does-not-support-overlay-mountopt-options/</link><pubDate>Tue, 13 Aug 2019 00:00:00 +0000</pubDate><guid>https://major.io/2019/08/13/buildah-error-vfs-driver-does-not-support-overlay-mountopt-options/</guid><description>Buildah and podman make a great pair for building, managing and running containers on a Linux system. You can even use them with GitLab CI with a few small adjustments, namely the switch from the overlayfs to vfs storage driver.
I have some regularly scheduled GitLab CI jobs that attempt to build fresh containers each morning and I use these to get the latest packages and find out early when something is broken in the build process.</description></item><item><title>Build containers in GitLab CI with buildah</title><link>https://major.io/2019/05/24/build-containers-in-gitlab-ci-with-buildah/</link><pubDate>Fri, 24 May 2019 00:00:00 +0000</pubDate><guid>https://major.io/2019/05/24/build-containers-in-gitlab-ci-with-buildah/</guid><description>My team at Red Hat depends heavily on GitLab CI and we build containers often to run all kinds of tests. Fortunately, GitLab offers up CI to build containers and a container registry in every repository to hold the containers we build.
This is really handy because it keeps everything together in one place: your container build scripts, your container build infrastructure, and the registry that holds your containers. Better yet, you can put multiple types of containers underneath a single git repository if you need to build containers based on different Linux distributions.</description></item><item><title>Running Ansible in OpenShift with arbitrary UIDs</title><link>https://major.io/2019/03/22/running-ansible-in-openshift-with-arbitrary-uids/</link><pubDate>Fri, 22 Mar 2019 00:00:00 +0000</pubDate><guid>https://major.io/2019/03/22/running-ansible-in-openshift-with-arbitrary-uids/</guid><description>My work at Red Hat involves testing lots and lots of kernels from various sources and we use GitLab CE to manage many of our repositories and run our CI jobs. Those jobs run in thousands of OpenShift containers that we spawn every day.
OpenShift has some handy security features that we like. First, each container is mounted read-only with some writable temporary space (and any volumes that you mount). Also, OpenShift uses arbitrarily assigned user IDs (UIDs) for each container.</description></item></channel></rss>