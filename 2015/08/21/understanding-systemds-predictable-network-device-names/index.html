<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content="Major Hayden"><meta name=description content="I talked a bit about systemd&amp;rsquo;s network device name in my earlier post about systemd-networkd and bonding and I received some questions about how systemd rolls through the possible names of network devices to choose the final name. These predictable network device names threw me a curveball last summer when I couldn&amp;rsquo;t figure out how the names were constructed.
Let&amp;rsquo;s walk through this process.
What&amp;rsquo;s in a name? Back in the systemd-networkd bonding post, I dug into a dual port Intel network card that showed up in a hotplug slot:"><meta name=keywords content=",centos,command line,fedora,linux,networking,systemd,udev"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://major.io/2015/08/21/understanding-systemds-predictable-network-device-names/><title>Understanding systemdâ€™s predictable network device names :: Major Hayden ðŸ¤  â€” Words of wisdom from a social nerd</title><link href=https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css rel=stylesheet type=text/css><link rel=stylesheet href=../../../../main.89fa80e2143f71bd5c96a7c94e531dec3276a367e22f87e74a76026ab64680bf.css><link rel=apple-touch-icon sizes=180x180 href=../../../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../../../favicon-16x16.png><link rel=manifest href=../../../../site.webmanifest><link rel=mask-icon href=../../../../safari-pinned-tab.svg color=#252627><link rel="shortcut icon" href=../../../../favicon.ico><meta name=msapplication-TileColor content="#252627"><meta name=theme-color content="#252627"><meta itemprop=name content="Understanding systemdâ€™s predictable network device names"><meta itemprop=description content="I talked a bit about systemd&rsquo;s network device name in my earlier post about systemd-networkd and bonding and I received some questions about how systemd rolls through the possible names of network devices to choose the final name. These predictable network device names threw me a curveball last summer when I couldn&rsquo;t figure out how the names were constructed.
Let&rsquo;s walk through this process.
What&rsquo;s in a name? Back in the systemd-networkd bonding post, I dug into a dual port Intel network card that showed up in a hotplug slot:"><meta itemprop=datePublished content="2015-08-21T21:15:36+00:00"><meta itemprop=dateModified content="2015-08-21T21:15:36+00:00"><meta itemprop=wordCount content="1310"><meta itemprop=image content="https://major.io"><meta itemprop=keywords content="centos,command line,fedora,linux,networking,systemd,udev,"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://major.io"><meta name=twitter:title content="Understanding systemdâ€™s predictable network device names"><meta name=twitter:description content="I talked a bit about systemd&rsquo;s network device name in my earlier post about systemd-networkd and bonding and I received some questions about how systemd rolls through the possible names of network devices to choose the final name. These predictable network device names threw me a curveball last summer when I couldn&rsquo;t figure out how the names were constructed.
Let&rsquo;s walk through this process.
What&rsquo;s in a name? Back in the systemd-networkd bonding post, I dug into a dual port Intel network card that showed up in a hotplug slot:"><meta name=twitter:site content="@mhayden"><meta property="article:section" content="Blog Posts"><meta property="article:published_time" content="2015-08-21 21:15:36 +0000 UTC"><style type=text/css>html{letter-spacing:unset}</style></head><body><div class=container><header class=header><span class=header__inner><a href=../../../../ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>$ echo major.io</span>
<span class=logo__cursor style=visibility:hidden></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=../../../../ham-radio-faq>hamradio</a></li><li><a href=../../../../icanhazip-com-faq>icanhazip</a></li><li><a href=../../../../posts/>posts</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span><span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M22 41c10.4934.0 19-8.5066 19-19C41 11.5066 32.4934 3 22 3 11.5066 3 3 11.5066 3 22s8.5066 19 19 19zM7 22C7 13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://major.io/2015/08/21/understanding-systemds-predictable-network-device-names/>Understanding systemdâ€™s predictable network device names</a></h2><div class=post-content><p><img src=../../../../wp-content/uploads/2015/08/2229782090_838eaa8574_o-e1440191509854.jpg alt=1></p><p>I talked a bit about systemd&rsquo;s network device name in my earlier post about <a href=../../../../2015/08/21/using-systemd-networkd-with-bonding-on-rackspaces-onmetal-servers/>systemd-networkd and bonding</a> and I received some questions about how systemd rolls through the possible names of network devices to choose the final name. These predictable network device names <a href=../../../../2014/08/06/unexpected-predictable-network-naming-systemd/>threw me a curveball last summer</a> when I couldn&rsquo;t figure out how the names were constructed.</p><p>Let&rsquo;s walk through this process.</p><h2 id=whats-in-a-name>What&rsquo;s in a name?</h2><p>Back in the systemd-networkd bonding post, I dug into a dual port Intel network card that showed up in a hotplug slot:</p><pre><code># udevadm info -e | grep -A 9 ^P.*eth0
P: /devices/pci0000:00/0000:00:03.2/0000:08:00.0/net/eth0
E: DEVPATH=/devices/pci0000:00/0000:00:03.2/0000:08:00.0/net/eth0
E: ID_BUS=pci
E: ID_MODEL_FROM_DATABASE=82599ES 10-Gigabit SFI/SFP+ Network Connection (Ethernet OCP Server Adapter X520-2)
E: ID_MODEL_ID=0x10fb
E: ID_NET_DRIVER=ixgbe
E: ID_NET_LINK_FILE=/usr/lib/systemd/network/99-default.link
E: ID_NET_NAME_MAC=enxa0369f2cec90
E: ID_NET_NAME_PATH=enp8s0f0
E: ID_NET_NAME_SLOT=ens9f0
</code></pre><p>This udev database dump shows that it came up with a few different names for the network interface:</p><ul><li><code>ID_NET_NAME_MAC=enxa0369f2cec90</code></li><li><code>ID_NET_NAME_PATH=enp8s0f0</code></li><li><code>ID_NET_NAME_SLOT=ens9f0</code></li></ul><p>Where do these names come from? We can dig into systemd&rsquo;s source code to figure out the origin of the names and which one is selected as the final choice.</p><h2 id=down-the-udev-rabbit-hole>Down the udev rabbit hole</h2><p>Let&rsquo;s take a look at <a href=https://github.com/systemd/systemd/blob/master/src/udev/udev-builtin-net_id.c>src/udev/udev-builtin-net_id.c</a>:</p><pre><code>/*
 * Predictable network interface device names based on:
 *  - firmware/bios-provided index numbers for on-board devices
 *  - firmware-provided pci-express hotplug slot index number
 *  - physical/geographical location of the hardware
 *  - the interface's MAC address
 *
 * http://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames
 *
 * Two character prefixes based on the type of interface:
 *   en -- ethernet
 *   sl -- serial line IP (slip)
 *   wl -- wlan
 *   ww -- wwan
 *
 * Type of names:
 *   b&lt;number&gt;                             -- BCMA bus core number
 *   ccw&lt;name&gt;                             -- CCW bus group name
 *   o&lt;index&gt;[d&lt;dev_port&gt;]                 -- on-board device index number
 *   s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_port&gt;]     -- hotplug slot index number
 *   x&lt;MAC&gt;                                -- MAC address
 *   [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_port&gt;]
 *                                         -- PCI geographical location
 *   [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][u&lt;port&gt;][..][c&lt;config&gt;][i&lt;interface&gt;]
 *                                         -- USB port number chain
</code></pre><p>So here&rsquo;s where our names actually begin. Ethernet cards will always start with <em>en</em>, but they might be followed by a <em>p</em> (for PCI slots), a <em>s</em> (for hotplug PCI-E slots), and <em>o</em> (for onboard cards). Scroll down just a bit more for some examples starting at line 56.</p><h2 id=real-world-examples>Real-world examples</h2><p>We already looked at the hotplug slot naming from Rackspace&rsquo;s OnMetal servers. They show up as <em>ens9f0</em> and <em>ens9f1</em>. That means they&rsquo;re on a hotplug slot which happens to be slot 9. The function indexes are 0 and 1 (for both ports on the Intel 82599ES).</p><h3 id=linux-firewall-with-a-dual-port-pci-card>Linux firewall with a dual-port PCI card</h3><p>Here&rsquo;s an example of my Linux firewall at home. It&rsquo;s a Dell Optiplex 3020 with an Intel I350-T2 (dual port):</p><pre><code># udevadm info -e | grep -A 10 ^P.*enp1s0f1
P: /devices/pci0000:00/0000:00:01.0/0000:01:00.1/net/enp1s0f1
E: DEVPATH=/devices/pci0000:00/0000:00:01.0/0000:01:00.1/net/enp1s0f1
E: ID_BUS=pci
E: ID_MODEL_FROM_DATABASE=I350 Gigabit Network Connection (Ethernet Server Adapter I350-T2)
E: ID_MODEL_ID=0x1521
E: ID_NET_DRIVER=igb
E: ID_NET_LINK_FILE=/usr/lib/systemd/network/99-default.link
E: ID_NET_NAME=enp1s0f1
E: ID_NET_NAME_MAC=enxa0369f6e5227
E: ID_NET_NAME_PATH=enp1s0f1
E: ID_OUI_FROM_DATABASE=Intel Corporate
</code></pre><p>And the output from <code>lspci</code>:</p><pre><code># lspci -s 01:00
01:00.0 Ethernet controller: Intel Corporation I350 Gigabit Network Connection (rev 01)
01:00.1 Ethernet controller: Intel Corporation I350 Gigabit Network Connection (rev 01)
</code></pre><p>This card happens to sit on PCI bus 1 (enp1), slot 0 (s0). Since it&rsquo;s a dual-port card, it has two function indexes (f0 and f1). That leaves me with two predictable names: <em>enp1s0f1</em> and <em>enp1s0f0</em>.</p><h3 id=1u-server-with-four-ethernet-ports>1U server with four ethernet ports</h3><p>Let&rsquo;s grab another example. Here&rsquo;s a SuperMicro 1U X9SCA server with four onboard PCI ethernet cards:</p><pre><code># udevadm info -e | grep -A 10 ^P.*enp2s0
P: /devices/pci0000:00/0000:00:1c.4/0000:02:00.0/net/enp2s0
E: DEVPATH=/devices/pci0000:00/0000:00:1c.4/0000:02:00.0/net/enp2s0
E: ID_BUS=pci
E: ID_MODEL_FROM_DATABASE=82574L Gigabit Network Connection
E: ID_MODEL_ID=0x10d3
E: ID_NET_DRIVER=e1000e
E: ID_NET_LINK_FILE=/usr/lib/systemd/network/99-default.link
E: ID_NET_NAME=enp2s0
E: ID_NET_NAME_MAC=enx00259025963a
E: ID_NET_NAME_PATH=enp2s0
E: ID_OUI_FROM_DATABASE=Super Micro Computer, Inc.
</code></pre><p>And here&rsquo;s all four ports in <code>lspci</code>:</p><pre><code># for i in `seq 2 5`; do lspci -s 0${i}:; done
02:00.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection
03:00.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection
04:00.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection
05:00.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection
</code></pre><p>These are interesting because they&rsquo;re not all on the same PCI bus. They sit on buses 2-5 in slot 0. There are no function indexes here, so they&rsquo;re named <em>enp2s0</em> through <em>enp5s0</em>. These aren&rsquo;t true <em>onboard</em> cards, so they&rsquo;re named based on their locations.</p><h3 id=storage-server-with-onboard-ethernet>Storage server with onboard ethernet</h3><p>Here&rsquo;s an example of a server with a true inboard ethernet card:</p><pre><code>$ udevadm info -e | grep -A 11 ^P.*eno1
P: /devices/pci0000:00/0000:00:19.0/net/eno1
E: DEVPATH=/devices/pci0000:00/0000:00:19.0/net/eno1
E: ID_BUS=pci
E: ID_MODEL_FROM_DATABASE=Ethernet Connection I217-V
E: ID_MODEL_ID=0x153b
E: ID_NET_DRIVER=e1000e
E: ID_NET_LABEL_ONBOARD=en Onboard LAN
E: ID_NET_LINK_FILE=/usr/lib/systemd/network/99-default.link
E: ID_NET_NAME_MAC=enxe03f49b159c0
E: ID_NET_NAME_ONBOARD=eno1
E: ID_NET_NAME_PATH=enp0s25
E: ID_OUI_FROM_DATABASE=ASUSTek COMPUTER INC.
</code></pre><p>And the <code>lspci</code> output:</p><pre><code>$ lspci -s 00:19.0
00:19.0 Ethernet controller: Intel Corporation Ethernet Connection I217-V (rev 05)
</code></pre><p>This card has a new name showing up in udev: <code>ID_NET_NAME_ONBOARD</code>. The systemd udev code has some special handling for onboard cards because they usually sit on the main bus. The naming can get a bit ugly because that 19 would need to be converted into hex for the name.</p><p>If systemd didn&rsquo;t handle onboard cards differently, this card might be named something ugly like enp0s13 (since 19 in decimal becomes 13 in hex). That&rsquo;s really confusing.</p><h2 id=picking-the-final-name>Picking the final name</h2><p>As we&rsquo;ve seen above, udev makes a big list of names in the udev database. However, there can only be one name in the OS when you try to use the network card.</p><p>Let&rsquo;s wander back into the code. this time we&rsquo;re going to take a look in <a href=https://github.com/systemd/systemd/blob/master/src/udev/net/link-config.c#L403>src/udev/net/link-config.c</a> starting at around line 403:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>name_policy) {
        NamePolicy <span style=color:#719e07>*</span>policy;

        <span style=color:#719e07>for</span> (policy <span style=color:#719e07>=</span> config<span style=color:#719e07>-&gt;</span>name_policy;
             <span style=color:#719e07>!</span>new_name <span style=color:#719e07>&amp;&amp;</span> <span style=color:#719e07>*</span>policy <span style=color:#719e07>!=</span> _NAMEPOLICY_INVALID; policy<span style=color:#719e07>++</span>) {
                <span style=color:#719e07>switch</span> (<span style=color:#719e07>*</span>policy) {
                        <span style=color:#719e07>case</span> NAMEPOLICY_KERNEL:
                                respect_predictable <span style=color:#719e07>=</span> <span style=color:#b58900>true</span>;
                                <span style=color:#719e07>break</span>;
                        <span style=color:#719e07>case</span> NAMEPOLICY_DATABASE:
                                new_name <span style=color:#719e07>=</span> udev_device_get_property_value(device, <span style=color:#2aa198>&#34;ID_NET_NAME_FROM_DATABASE&#34;</span>);
                                <span style=color:#719e07>break</span>;
                        <span style=color:#719e07>case</span> NAMEPOLICY_ONBOARD:
                                new_name <span style=color:#719e07>=</span> udev_device_get_property_value(device, <span style=color:#2aa198>&#34;ID_NET_NAME_ONBOARD&#34;</span>);
                                <span style=color:#719e07>break</span>;
                        <span style=color:#719e07>case</span> NAMEPOLICY_SLOT:
                                new_name <span style=color:#719e07>=</span> udev_device_get_property_value(device, <span style=color:#2aa198>&#34;ID_NET_NAME_SLOT&#34;</span>);
                                <span style=color:#719e07>break</span>;
                        <span style=color:#719e07>case</span> NAMEPOLICY_PATH:
                                new_name <span style=color:#719e07>=</span> udev_device_get_property_value(device, <span style=color:#2aa198>&#34;ID_NET_NAME_PATH&#34;</span>);
                                <span style=color:#719e07>break</span>;
                        <span style=color:#719e07>case</span> NAMEPOLICY_MAC:
                                new_name <span style=color:#719e07>=</span> udev_device_get_property_value(device, <span style=color:#2aa198>&#34;ID_NET_NAME_MAC&#34;</span>);
                                <span style=color:#719e07>break</span>;
                        <span style=color:#719e07>default</span><span style=color:#719e07>:</span>
                                <span style=color:#719e07>break</span>;
                }
        }
}
</code></pre></div><p>If we look at the overall case statement, you can see that the first match is the one that takes precedence. Working from top to bottom, udev takes the first match of:</p><ul><li><code>ID_NET_NAME_FROM_DATABASE</code></li><li><code>ID_NET_NAME_ONBOARD</code></li><li><code>ID_NET_NAME_SLOT</code></li><li><code>ID_NET_NAME_PATH</code></li><li><code>ID_NET_NAME_MAC</code></li></ul><p>If we go back to our OnMetal example way at the top of the post, we can follow the logic. The udev database contained the following:</p><pre><code>E: ID_NET_NAME_MAC=enxa0369f2cec90
E: ID_NET_NAME_PATH=enp8s0f0
E: ID_NET_NAME_SLOT=ens9f0
</code></pre><p>The udev daemon would start with <code>ID_NET_NAME_FROM_DATABASE</code>, but that doesn&rsquo;t exist for this card. Next, it would move to <code>ID_NET_NAME_ONBOARD</code>, but that&rsquo;s not present. Next comes <code>ID_NET_NAME_SLOT</code>, and we have a match! The <code>ID_NET_NAME_SLOT</code> entry has <em>ens9f0</em> and that&rsquo;s the final name for the network device.</p><p>This loop also handles some special cases. The first check is to see if someone requested for udev to not use predictable naming. We saw this in the <a href=../../../../2015/08/21/using-systemd-networkd-with-bonding-on-rackspaces-onmetal-servers/>systemd-networkd bonding post</a> when the bootloader configuration contained <em>net.ifnames=0</em>. If that kernel command line parameter is present, predictable naming logic is skipped.</p><p>Another special case is <code>ID_NET_NAME_FROM_DATABASE</code>. Those ports come from udev&rsquo;s internal <a href=https://github.com/systemd/systemd/blob/master/hwdb/20-net-ifname.hwdb>hardware database</a>. That file only has one item at the moment and it&rsquo;s for a particular Dell iDRAC network interface.</p><h2 id=perplexed-by-hex>Perplexed by hex</h2><p>If the PCI slot numbers don&rsquo;t seem to line up, be sure to <a href=../../../../2014/08/06/unexpected-predictable-network-naming-systemd/>read my post from last summer</a>. I ran into a peculiar Dell server with a dual port Intel card on PCI bus 42. The interface ended up with a name of <em>enp66s0f0</em> and I was stumped.</p><p>The name <em>enp66s0f0</em> seems to say that we have a card on PCI bus 66, in slot 0, with multiple function index numbers (for multiple ports). However, systemd does a conversion of PCI slot numbers into hex. That means that decimal 66 becomes 42 in hex.</p><p>Most servers won&rsquo;t be this complicated, but it&rsquo;s key to remember the hex conversion.</p><h2 id=feedback>Feedback</h2><p>Are these systemd-related posts interesting? Let me know. I&rsquo;m a huge fan of systemd and I enjoy writing about it.</p><p><em>Photo credit: <a href=https://www.flickr.com/photos/mlibrary/2229782090>University of Michigan Library</a></em></p></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg><span class=tag><a href=https://major.io/tags/centos/>centos</a></span>
<span class=tag><a href=https://major.io/tags/command-line/>command line</a></span>
<span class=tag><a href=https://major.io/tags/fedora/>fedora</a></span>
<span class=tag><a href=https://major.io/tags/linux/>linux</a></span>
<span class=tag><a href=https://major.io/tags/networking/>networking</a></span>
<span class=tag><a href=https://major.io/tags/systemd/>systemd</a></span>
<span class=tag><a href=https://major.io/tags/udev/>udev</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 01-2 2H4a2 2 0 01-2-2V5a2 2 0 012-2h5l2 3h9a2 2 0 012 2z"/></svg><span class=tag><a href=https://major.io/categories/blog-posts/>Blog Posts</a></span></p></div></main></div><footer class=footer><div class=footer__inner><div class=footer__content><span>&copy; 2021</span>
<span><a href=https://major.io>Major Hayden</a></span>
<span><a href=https://creativecommons.org/licenses/by-sa/2.0/ target=_blank rel=noopener>CC BY-SA 2.0</a></span><span><a href=https://major.io/posts/index.xml target=_blank title=rss><svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 20 20" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></span></div></div><div class=footer__inner><div class=footer__content><span>Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>Made with &#10084; by <a href=https://github.com/rhazdon>Djordje Atlialp</a></span></div></div></footer></div><script type=text/javascript src=../../../../bundle.min.e9f93b80e78a22e6f04cbb5f73e0f9c4ba60ff73a2a0ef85965c688f93dd1f2722a282e30e485603e4c65b1b346720e35f213435ec5556e196a97a68d097c80f.js integrity="sha512-6fk7gOeKIubwTLtfc+D5xLpg/3OioO+Fllxoj5PdHyciooLjDkhWA+TGWxs0ZyDjXyE0NexVVuGWqXpo0JfIDw=="></script></body></html>