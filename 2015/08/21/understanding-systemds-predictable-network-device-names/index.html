<!doctype html><html lang=en-us><head><meta http-equiv=x-clacks-overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://major.io/favicon.ico><title>Understanding systemdâ€™s predictable network device names | Major Hayden's Blog ðŸ¤ </title><meta name=title content="Understanding systemdâ€™s predictable network device names"><meta name=description content="I talked a bit about systemd&rsquo;s network device name in my earlier post about systemd-networkd and bonding and I received some questions about how systemd rolls through the possible names of network devices to choose the final name. These predictable network device names threw me a curveball last summer when I couldn&rsquo;t figure out how the names were constructed.
Let&rsquo;s walk through this process.
What&rsquo;s in a name? Back in the systemd-networkd bonding post, I dug into a dual port Intel network card that showed up in a hotplug slot:"><meta name=keywords content="centos,command line,fedora,linux,networking,systemd,udev,"><meta property="og:title" content="Understanding systemdâ€™s predictable network device names"><meta property="og:description" content="I talked a bit about systemd&rsquo;s network device name in my earlier post about systemd-networkd and bonding and I received some questions about how systemd rolls through the possible names of network devices to choose the final name. These predictable network device names threw me a curveball last summer when I couldn&rsquo;t figure out how the names were constructed.
Let&rsquo;s walk through this process.
What&rsquo;s in a name? Back in the systemd-networkd bonding post, I dug into a dual port Intel network card that showed up in a hotplug slot:"><meta property="og:type" content="article"><meta property="og:url" content="https://major.io/2015/08/21/understanding-systemds-predictable-network-device-names/"><meta property="og:image" content="https://major.io/images/2019-05-24-cranes-skycrapers.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-08-21T21:15:36+00:00"><meta property="article:modified_time" content="2015-08-21T21:15:36+00:00"><meta property="og:site_name" content="Major Hayden's Blog ðŸ¤ "><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://major.io/images/2019-05-24-cranes-skycrapers.jpg"><meta name=twitter:title content="Understanding systemdâ€™s predictable network device names"><meta name=twitter:description content="I talked a bit about systemd&rsquo;s network device name in my earlier post about systemd-networkd and bonding and I received some questions about how systemd rolls through the possible names of network devices to choose the final name. These predictable network device names threw me a curveball last summer when I couldn&rsquo;t figure out how the names were constructed.
Let&rsquo;s walk through this process.
What&rsquo;s in a name? Back in the systemd-networkd bonding post, I dug into a dual port Intel network card that showed up in a hotplug slot:"><meta name=twitter:site content="@mhayden"><meta itemprop=name content="Understanding systemdâ€™s predictable network device names"><meta itemprop=description content="I talked a bit about systemd&rsquo;s network device name in my earlier post about systemd-networkd and bonding and I received some questions about how systemd rolls through the possible names of network devices to choose the final name. These predictable network device names threw me a curveball last summer when I couldn&rsquo;t figure out how the names were constructed.
Let&rsquo;s walk through this process.
What&rsquo;s in a name? Back in the systemd-networkd bonding post, I dug into a dual port Intel network card that showed up in a hotplug slot:"><meta itemprop=datePublished content="2015-08-21T21:15:36+00:00"><meta itemprop=dateModified content="2015-08-21T21:15:36+00:00"><meta itemprop=wordCount content="1310"><meta itemprop=image content="https://major.io/images/2019-05-24-cranes-skycrapers.jpg"><meta itemprop=keywords content="centos,command line,fedora,linux,networking,systemd,udev,"><meta name=referrer content="no-referrer-when-downgrade"><style>body{font-family:Verdana,sans-serif;margin:auto;padding:20px;max-width:820px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}h1,h2,h3,h4,h5,h6,strong,b{color:#222}a{color:#3273dc}.title{text-decoration:none;border:0}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px}div.highlight code{background-color:unset;color:initial}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.helptext{color:#777;font-size:small}.errorlist{color:#eba613;font-size:small}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#333;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#777}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}.helptext{color:#aaa}}</style></head><body><header><a href=../../../../ class=title><h2>Major Hayden's Blog ðŸ¤ </h2></a><nav><a href=../../../../>Home</a>
<a href=../../../../ham-radio-faq>Ham Radio</a>
<a href=../../../../icanhazip-com-faq>icanhazip FAQ</a>
<a href=../../../../posts>Posts</a></nav><script async src=https://media.ethicalads.io/media/client/ethicalads.min.js></script><div data-ea-publisher=major-io data-ea-type=text></div></header><main><h1>Understanding systemdâ€™s predictable network device names</h1><i><time datetime=2015-08-21 pubdate>2015-08-21</time></i>
<content><p><img src=../../../../wp-content/uploads/2015/08/2229782090_838eaa8574_o-e1440191509854.jpg alt=1></p><p>I talked a bit about systemd&rsquo;s network device name in my earlier post about <a href=../../../../2015/08/21/using-systemd-networkd-with-bonding-on-rackspaces-onmetal-servers/>systemd-networkd and bonding</a> and I received some questions about how systemd rolls through the possible names of network devices to choose the final name. These predictable network device names <a href=../../../../2014/08/06/unexpected-predictable-network-naming-systemd/>threw me a curveball last summer</a> when I couldn&rsquo;t figure out how the names were constructed.</p><p>Let&rsquo;s walk through this process.</p><h2 id=whats-in-a-name>What&rsquo;s in a name?</h2><p>Back in the systemd-networkd bonding post, I dug into a dual port Intel network card that showed up in a hotplug slot:</p><pre><code># udevadm info -e | grep -A 9 ^P.*eth0
P: /devices/pci0000:00/0000:00:03.2/0000:08:00.0/net/eth0
E: DEVPATH=/devices/pci0000:00/0000:00:03.2/0000:08:00.0/net/eth0
E: ID_BUS=pci
E: ID_MODEL_FROM_DATABASE=82599ES 10-Gigabit SFI/SFP+ Network Connection (Ethernet OCP Server Adapter X520-2)
E: ID_MODEL_ID=0x10fb
E: ID_NET_DRIVER=ixgbe
E: ID_NET_LINK_FILE=/usr/lib/systemd/network/99-default.link
E: ID_NET_NAME_MAC=enxa0369f2cec90
E: ID_NET_NAME_PATH=enp8s0f0
E: ID_NET_NAME_SLOT=ens9f0
</code></pre><p>This udev database dump shows that it came up with a few different names for the network interface:</p><ul><li><code>ID_NET_NAME_MAC=enxa0369f2cec90</code></li><li><code>ID_NET_NAME_PATH=enp8s0f0</code></li><li><code>ID_NET_NAME_SLOT=ens9f0</code></li></ul><p>Where do these names come from? We can dig into systemd&rsquo;s source code to figure out the origin of the names and which one is selected as the final choice.</p><h2 id=down-the-udev-rabbit-hole>Down the udev rabbit hole</h2><p>Let&rsquo;s take a look at <a href=https://github.com/systemd/systemd/blob/master/src/udev/udev-builtin-net_id.c>src/udev/udev-builtin-net_id.c</a>:</p><pre><code>/*
 * Predictable network interface device names based on:
 *  - firmware/bios-provided index numbers for on-board devices
 *  - firmware-provided pci-express hotplug slot index number
 *  - physical/geographical location of the hardware
 *  - the interface's MAC address
 *
 * http://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames
 *
 * Two character prefixes based on the type of interface:
 *   en -- ethernet
 *   sl -- serial line IP (slip)
 *   wl -- wlan
 *   ww -- wwan
 *
 * Type of names:
 *   b&lt;number&gt;                             -- BCMA bus core number
 *   ccw&lt;name&gt;                             -- CCW bus group name
 *   o&lt;index&gt;[d&lt;dev_port&gt;]                 -- on-board device index number
 *   s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_port&gt;]     -- hotplug slot index number
 *   x&lt;MAC&gt;                                -- MAC address
 *   [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][d&lt;dev_port&gt;]
 *                                         -- PCI geographical location
 *   [P&lt;domain&gt;]p&lt;bus&gt;s&lt;slot&gt;[f&lt;function&gt;][u&lt;port&gt;][..][c&lt;config&gt;][i&lt;interface&gt;]
 *                                         -- USB port number chain
</code></pre><p>So here&rsquo;s where our names actually begin. Ethernet cards will always start with <em>en</em>, but they might be followed by a <em>p</em> (for PCI slots), a <em>s</em> (for hotplug PCI-E slots), and <em>o</em> (for onboard cards). Scroll down just a bit more for some examples starting at line 56.</p><h2 id=real-world-examples>Real-world examples</h2><p>We already looked at the hotplug slot naming from Rackspace&rsquo;s OnMetal servers. They show up as <em>ens9f0</em> and <em>ens9f1</em>. That means they&rsquo;re on a hotplug slot which happens to be slot 9. The function indexes are 0 and 1 (for both ports on the Intel 82599ES).</p><h3 id=linux-firewall-with-a-dual-port-pci-card>Linux firewall with a dual-port PCI card</h3><p>Here&rsquo;s an example of my Linux firewall at home. It&rsquo;s a Dell Optiplex 3020 with an Intel I350-T2 (dual port):</p><pre><code># udevadm info -e | grep -A 10 ^P.*enp1s0f1
P: /devices/pci0000:00/0000:00:01.0/0000:01:00.1/net/enp1s0f1
E: DEVPATH=/devices/pci0000:00/0000:00:01.0/0000:01:00.1/net/enp1s0f1
E: ID_BUS=pci
E: ID_MODEL_FROM_DATABASE=I350 Gigabit Network Connection (Ethernet Server Adapter I350-T2)
E: ID_MODEL_ID=0x1521
E: ID_NET_DRIVER=igb
E: ID_NET_LINK_FILE=/usr/lib/systemd/network/99-default.link
E: ID_NET_NAME=enp1s0f1
E: ID_NET_NAME_MAC=enxa0369f6e5227
E: ID_NET_NAME_PATH=enp1s0f1
E: ID_OUI_FROM_DATABASE=Intel Corporate
</code></pre><p>And the output from <code>lspci</code>:</p><pre><code># lspci -s 01:00
01:00.0 Ethernet controller: Intel Corporation I350 Gigabit Network Connection (rev 01)
01:00.1 Ethernet controller: Intel Corporation I350 Gigabit Network Connection (rev 01)
</code></pre><p>This card happens to sit on PCI bus 1 (enp1), slot 0 (s0). Since it&rsquo;s a dual-port card, it has two function indexes (f0 and f1). That leaves me with two predictable names: <em>enp1s0f1</em> and <em>enp1s0f0</em>.</p><h3 id=1u-server-with-four-ethernet-ports>1U server with four ethernet ports</h3><p>Let&rsquo;s grab another example. Here&rsquo;s a SuperMicro 1U X9SCA server with four onboard PCI ethernet cards:</p><pre><code># udevadm info -e | grep -A 10 ^P.*enp2s0
P: /devices/pci0000:00/0000:00:1c.4/0000:02:00.0/net/enp2s0
E: DEVPATH=/devices/pci0000:00/0000:00:1c.4/0000:02:00.0/net/enp2s0
E: ID_BUS=pci
E: ID_MODEL_FROM_DATABASE=82574L Gigabit Network Connection
E: ID_MODEL_ID=0x10d3
E: ID_NET_DRIVER=e1000e
E: ID_NET_LINK_FILE=/usr/lib/systemd/network/99-default.link
E: ID_NET_NAME=enp2s0
E: ID_NET_NAME_MAC=enx00259025963a
E: ID_NET_NAME_PATH=enp2s0
E: ID_OUI_FROM_DATABASE=Super Micro Computer, Inc.
</code></pre><p>And here&rsquo;s all four ports in <code>lspci</code>:</p><pre><code># for i in `seq 2 5`; do lspci -s 0${i}:; done
02:00.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection
03:00.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection
04:00.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection
05:00.0 Ethernet controller: Intel Corporation 82574L Gigabit Network Connection
</code></pre><p>These are interesting because they&rsquo;re not all on the same PCI bus. They sit on buses 2-5 in slot 0. There are no function indexes here, so they&rsquo;re named <em>enp2s0</em> through <em>enp5s0</em>. These aren&rsquo;t true <em>onboard</em> cards, so they&rsquo;re named based on their locations.</p><h3 id=storage-server-with-onboard-ethernet>Storage server with onboard ethernet</h3><p>Here&rsquo;s an example of a server with a true inboard ethernet card:</p><pre><code>$ udevadm info -e | grep -A 11 ^P.*eno1
P: /devices/pci0000:00/0000:00:19.0/net/eno1
E: DEVPATH=/devices/pci0000:00/0000:00:19.0/net/eno1
E: ID_BUS=pci
E: ID_MODEL_FROM_DATABASE=Ethernet Connection I217-V
E: ID_MODEL_ID=0x153b
E: ID_NET_DRIVER=e1000e
E: ID_NET_LABEL_ONBOARD=en Onboard LAN
E: ID_NET_LINK_FILE=/usr/lib/systemd/network/99-default.link
E: ID_NET_NAME_MAC=enxe03f49b159c0
E: ID_NET_NAME_ONBOARD=eno1
E: ID_NET_NAME_PATH=enp0s25
E: ID_OUI_FROM_DATABASE=ASUSTek COMPUTER INC.
</code></pre><p>And the <code>lspci</code> output:</p><pre><code>$ lspci -s 00:19.0
00:19.0 Ethernet controller: Intel Corporation Ethernet Connection I217-V (rev 05)
</code></pre><p>This card has a new name showing up in udev: <code>ID_NET_NAME_ONBOARD</code>. The systemd udev code has some special handling for onboard cards because they usually sit on the main bus. The naming can get a bit ugly because that 19 would need to be converted into hex for the name.</p><p>If systemd didn&rsquo;t handle onboard cards differently, this card might be named something ugly like enp0s13 (since 19 in decimal becomes 13 in hex). That&rsquo;s really confusing.</p><h2 id=picking-the-final-name>Picking the final name</h2><p>As we&rsquo;ve seen above, udev makes a big list of names in the udev database. However, there can only be one name in the OS when you try to use the network card.</p><p>Let&rsquo;s wander back into the code. this time we&rsquo;re going to take a look in <a href=https://github.com/systemd/systemd/blob/master/src/udev/net/link-config.c#L403>src/udev/net/link-config.c</a> starting at around line 403:</p><div class=highlight><pre style=color:#586e75;background-color:#eee8d5;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#268bd2>name_policy</span>) {
        <span style=color:#268bd2>NamePolicy</span> *<span style=color:#268bd2>policy</span>;

        <span style=color:#859900>for</span> (<span style=color:#268bd2>policy</span> = <span style=color:#268bd2>config</span>-&gt;<span style=color:#268bd2>name_policy</span>;
             !<span style=color:#268bd2>new_name</span> &amp;&amp; *<span style=color:#268bd2>policy</span> != <span style=color:#268bd2>_NAMEPOLICY_INVALID</span>; <span style=color:#268bd2>policy</span>++) {
                <span style=color:#859900>switch</span> (*<span style=color:#268bd2>policy</span>) {
                        <span style=color:#859900>case</span> <span style=color:#268bd2>NAMEPOLICY_KERNEL</span>:
                                <span style=color:#268bd2>respect_predictable</span> = <span style=color:#cb4b16>true</span>;
                                <span style=color:#859900>break</span>;
                        <span style=color:#859900>case</span> <span style=color:#268bd2>NAMEPOLICY_DATABASE</span>:
                                <span style=color:#268bd2>new_name</span> = <span style=color:#268bd2>udev_device_get_property_value</span>(<span style=color:#268bd2>device</span>, <span style=color:#2aa198>&#34;ID_NET_NAME_FROM_DATABASE&#34;</span>);
                                <span style=color:#859900>break</span>;
                        <span style=color:#859900>case</span> <span style=color:#268bd2>NAMEPOLICY_ONBOARD</span>:
                                <span style=color:#268bd2>new_name</span> = <span style=color:#268bd2>udev_device_get_property_value</span>(<span style=color:#268bd2>device</span>, <span style=color:#2aa198>&#34;ID_NET_NAME_ONBOARD&#34;</span>);
                                <span style=color:#859900>break</span>;
                        <span style=color:#859900>case</span> <span style=color:#268bd2>NAMEPOLICY_SLOT</span>:
                                <span style=color:#268bd2>new_name</span> = <span style=color:#268bd2>udev_device_get_property_value</span>(<span style=color:#268bd2>device</span>, <span style=color:#2aa198>&#34;ID_NET_NAME_SLOT&#34;</span>);
                                <span style=color:#859900>break</span>;
                        <span style=color:#859900>case</span> <span style=color:#268bd2>NAMEPOLICY_PATH</span>:
                                <span style=color:#268bd2>new_name</span> = <span style=color:#268bd2>udev_device_get_property_value</span>(<span style=color:#268bd2>device</span>, <span style=color:#2aa198>&#34;ID_NET_NAME_PATH&#34;</span>);
                                <span style=color:#859900>break</span>;
                        <span style=color:#859900>case</span> <span style=color:#268bd2>NAMEPOLICY_MAC</span>:
                                <span style=color:#268bd2>new_name</span> = <span style=color:#268bd2>udev_device_get_property_value</span>(<span style=color:#268bd2>device</span>, <span style=color:#2aa198>&#34;ID_NET_NAME_MAC&#34;</span>);
                                <span style=color:#859900>break</span>;
                        <span style=color:#859900>default</span>:
                                <span style=color:#859900>break</span>;
                }
        }
}
</code></pre></div><p>If we look at the overall case statement, you can see that the first match is the one that takes precedence. Working from top to bottom, udev takes the first match of:</p><ul><li><code>ID_NET_NAME_FROM_DATABASE</code></li><li><code>ID_NET_NAME_ONBOARD</code></li><li><code>ID_NET_NAME_SLOT</code></li><li><code>ID_NET_NAME_PATH</code></li><li><code>ID_NET_NAME_MAC</code></li></ul><p>If we go back to our OnMetal example way at the top of the post, we can follow the logic. The udev database contained the following:</p><pre><code>E: ID_NET_NAME_MAC=enxa0369f2cec90
E: ID_NET_NAME_PATH=enp8s0f0
E: ID_NET_NAME_SLOT=ens9f0
</code></pre><p>The udev daemon would start with <code>ID_NET_NAME_FROM_DATABASE</code>, but that doesn&rsquo;t exist for this card. Next, it would move to <code>ID_NET_NAME_ONBOARD</code>, but that&rsquo;s not present. Next comes <code>ID_NET_NAME_SLOT</code>, and we have a match! The <code>ID_NET_NAME_SLOT</code> entry has <em>ens9f0</em> and that&rsquo;s the final name for the network device.</p><p>This loop also handles some special cases. The first check is to see if someone requested for udev to not use predictable naming. We saw this in the <a href=../../../../2015/08/21/using-systemd-networkd-with-bonding-on-rackspaces-onmetal-servers/>systemd-networkd bonding post</a> when the bootloader configuration contained <em>net.ifnames=0</em>. If that kernel command line parameter is present, predictable naming logic is skipped.</p><p>Another special case is <code>ID_NET_NAME_FROM_DATABASE</code>. Those ports come from udev&rsquo;s internal hardware database. That file only has one item at the moment and it&rsquo;s for a particular Dell iDRAC network interface.</p><h2 id=perplexed-by-hex>Perplexed by hex</h2><p>If the PCI slot numbers don&rsquo;t seem to line up, be sure to <a href=../../../../2014/08/06/unexpected-predictable-network-naming-systemd/>read my post from last summer</a>. I ran into a peculiar Dell server with a dual port Intel card on PCI bus 42. The interface ended up with a name of <em>enp66s0f0</em> and I was stumped.</p><p>The name <em>enp66s0f0</em> seems to say that we have a card on PCI bus 66, in slot 0, with multiple function index numbers (for multiple ports). However, systemd does a conversion of PCI slot numbers into hex. That means that decimal 66 becomes 42 in hex.</p><p>Most servers won&rsquo;t be this complicated, but it&rsquo;s key to remember the hex conversion.</p><h2 id=feedback>Feedback</h2><p>Are these systemd-related posts interesting? Let me know. I&rsquo;m a huge fan of systemd and I enjoy writing about it.</p><p><em>Photo credit: <a href=https://www.flickr.com/photos/mlibrary/2229782090>University of Michigan Library</a></em></p></content><p><a href=https://major.io/tags/centos/>#centos</a>
<a href=https://major.io/tags/command-line/>#command line</a>
<a href=https://major.io/tags/fedora/>#fedora</a>
<a href=https://major.io/tags/linux/>#linux</a>
<a href=https://major.io/tags/networking/>#networking</a>
<a href=https://major.io/tags/systemd/>#systemd</a>
<a href=https://major.io/tags/udev/>#udev</a></p></main><footer><hr>CC-BY-SA 4.0 &#187;
Made with <a href=https://gohugo.io/>Hugo</a> &#187;
Theme based on <a href=https://github.com/janraasch/hugo-bearblog/>Hugo Ê•â€¢á´¥â€¢Ê” Bear</a><br></footer></body></html>